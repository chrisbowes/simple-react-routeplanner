{"version":3,"sources":["store/app.store.js","components/waypoint-list-item/waypoint-list-item.component.js","components/info-box/info-box.component.js","components/waypoint-list/waypoint-list.component.js","components/leaflet-map/leaflet-map.component.js","components/download-route/download-route.component.js","App.js","serviceWorker.js","index.js"],"names":["Store","React","createContext","initialState","markers","polylines","reducer","state","action","type","payload","filter","marker","Error","StoreProvider","props","useReducer","value","dispatch","Provider","children","WaypointListLi","styled","li","WaypointListItemInner","div","WaypointButton","button","WaypointLabel","span","Waypoint","useContext","onDragOver","handleOnDragOver","index","draggable","onDragStart","e","handleOnDragStart","onDragEnd","handleOnDragEnd","icon","onClick","data","InfoBoxEl","InfoBox","WaypointListUl","ul","WaypointList","useState","draggedItem","setDraggedItem","draggedOverItem","setDraggedOverItem","markersList","setMarkersList","useEffect","dataTransfer","effectAllowed","setData","target","parentNode","setDragImage","items","item","splice","length","map","key","MapWrapper","LeafletMap","mapRef","useRef","layerRef","current","L","center","zoom","layers","tileLayer","attribution","on","latlng","toGeoJSON","layerGroup","addTo","clearLayers","polylineGeoJson","polyLineCoords","lat","geometry","coordinates","lng","push","polyline","color","id","DownloadButton","DownloadRoute","createExportObj","downloadDataUri","togpx","href","download","disabled","library","add","faTrashAlt","faBars","AppWrapper","Styled","AppSidebar","AppTitle","h1","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.38535348.chunk.js","sourcesContent":["import React from 'react'\n\nexport const Store = React.createContext();\n\nconst initialState = {\n    markers: [],\n    polylines: []\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'ADD_MARKER':\n      return { ...state, markers: [...state.markers, action.payload]};\n    case 'DELETE_MARKER':\n      return {...state, markers: [...state.markers.filter((marker) => marker !== action.payload)]};\n    case 'REORDER_MARKERS':\n        return {...state, markers: action.payload}\n    case 'UPDATE_POLYLINES':\n        return {...state, polylines: action.payload}\n    default:\n      throw new Error();\n  }\n}\n\nexport function StoreProvider(props) {\n    const [state, dispatch] = React.useReducer(reducer, initialState);\n    const value = { state, dispatch };\n    return <Store.Provider value={value}>{props.children}</Store.Provider>\n}","import React from 'react';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { Store } from '../../store/app.store';\nimport styled from 'styled-components';\n\nconst WaypointListLi = styled.li`\n    list-style-type: none;\n    margin: 0.2rem 0;\n    padding: 0.2rem 0;\n    box-sizing: border-box;\n`;\n\nconst WaypointListItemInner = styled.div`\n    display: flex;\n    justify-content: space-between;\n`;\n\nconst WaypointButton = styled.button`\n    color: #747474;\n    background-color: #383838;\n    border: none;\n    font-size: 1rem;\n    margin: 0;\n    padding: 0;\n`;\n\nconst WaypointLabel = styled.span`\n    display: inline-block;\n    padding: 0 1rem;\n`;\n\nconst Waypoint = (props) => {\n    const { dispatch } = React.useContext(Store);\n    return (\n        <WaypointListLi onDragOver={() => props.handleOnDragOver(props.index)}>\n            <WaypointListItemInner\n                draggable\n                onDragStart={e => props.handleOnDragStart(e, props.index)}\n                onDragEnd={props.handleOnDragEnd}>\n                <span>\n                    <WaypointButton><FontAwesomeIcon icon=\"bars\" /></WaypointButton>\n                    <WaypointLabel>Waypoint {props.index + 1}</WaypointLabel>\n                </span>\n                <WaypointButton onClick={() => dispatch({ type: 'DELETE_MARKER', payload: props.data })}><FontAwesomeIcon icon=\"trash-alt\" /></WaypointButton>\n            </WaypointListItemInner>\n        </WaypointListLi>\n    )\n}\n\nexport default Waypoint;","import React from 'react';\nimport styled from 'styled-components';\n\nconst InfoBoxEl = styled.div`\n    border-radius: 0.3rem;\n    box-sizing: border-box;\n    border: 1px solid #e1e1e1;\n    padding: 1rem;\n    line-height: 1.2;\n    font-size: 0.8rem;\n    `;\n\nconst InfoBox = (props) => {\n    return (\n        <InfoBoxEl>\n            {props.children}\n        </InfoBoxEl>\n    )\n};\n\nexport default InfoBox;","import React from 'react';\nimport Waypoint from '../waypoint-list-item/waypoint-list-item.component';\nimport { Store } from '../../store/app.store';\nimport styled from 'styled-components';\nimport InfoBox from '../info-box/info-box.component';\n\nconst WaypointListUl = styled.ul`\n    margin: 0;\n    padding: 0;\n`;\n\nconst WaypointList = () => {\n    const { state, dispatch } = React.useContext(Store);\n    const [draggedItem, setDraggedItem] = React.useState();\n    const [draggedOverItem, setDraggedOverItem] = React.useState();\n    const [markersList, setMarkersList] = React.useState();\n    React.useEffect(() => {\n        setMarkersList(state.markers)\n    },[])\n    const handleOnDragStart = (e, index) => {\n        setDraggedItem(state.markers[index]);\n        e.dataTransfer.effectAllowed = \"move\";\n        e.dataTransfer.setData(\"text/html\", e.target.parentNode);\n        e.dataTransfer.setDragImage(e.target.parentNode, 20, 20);\n    };\n    const handleOnDragOver = index => {\n        setDraggedOverItem(state.markers[index]);  \n        if (draggedItem === draggedOverItem) {\n          return;\n        }   \n        let items = state.markers.filter(item => item !== draggedItem);    \n        items.splice(index, 0, draggedItem); \n        setMarkersList(items);\n         \n      };\n    const handleOnDragEnd = () => {\n        dispatch({ type: 'REORDER_MARKERS', payload: markersList }) \n      };\n    return (\n        <>\n            { state.markers.length ?\n            <WaypointListUl>\n                { state.markers.map((marker, index) => {\n                    return (\n                        <Waypoint \n                            key={index}\n                            data={marker} \n                            index={index}\n                            handleOnDragStart={handleOnDragStart}\n                            handleOnDragEnd={handleOnDragEnd}\n                            handleOnDragOver={handleOnDragOver}/> \n                    )}\n                )}\n            </WaypointListUl>\n            :\n            <InfoBox>\n                Add markers to the map to build a sortable list. Delete and rearrange as desired. Then use the download option below to export your route in GPX format.\n            </InfoBox>\n            }\n        </>\n    )\n}\n\nexport default WaypointList;","import React from 'react';\nimport L from 'leaflet';\nimport styled from 'styled-components';\nimport { Store } from '../../store/app.store';\n\n\nconst MapWrapper = styled.div`\n    width: 100%;\n    height: 100vh;\n    `\nconst LeafletMap = () => {\n    const mapRef = React.useRef(null);\n    const layerRef = React.useRef(null);\n    const { state, dispatch } = React.useContext(Store);\n\n    React.useEffect(() => {\n        mapRef.current = L.map(\"map\", {\n            center: [45.51, -122.68],\n            zoom: 16,\n            layers: [\n                L.tileLayer(\"http://{s}.tile.osm.org/{z}/{x}/{y}.png\", {\n                    attribution:\n                        '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n                })\n            ]\n        });\n        mapRef.current.on('click', (e) => {\n            dispatch({ type: 'ADD_MARKER', payload: L.marker(e.latlng).toGeoJSON() })\n        });\n    }, [dispatch]);\n\n    React.useEffect(() => {\n        layerRef.current = L.layerGroup().addTo(mapRef.current);\n    }, []);\n\n    React.useEffect(() => {\n        layerRef.current.clearLayers();\n        let polylineGeoJson = [];\n        if (state.markers.length) {\n            const polyLineCoords = [];\n            state.markers.map((marker) => {\n                const latlng = { lat: marker.geometry.coordinates[1], lng: marker.geometry.coordinates[0] };\n                polyLineCoords.push(latlng);\n                L.marker(latlng).addTo(layerRef.current)\n            });\n            L.polyline(polyLineCoords, { color: 'red' }).addTo(layerRef.current);\n            polylineGeoJson = [...polylineGeoJson, L.polyline(polyLineCoords, { color: 'red' }).toGeoJSON()]\n        }\n        dispatch({ type: 'UPDATE_POLYLINES', payload: polylineGeoJson });\n    }, [state.markers]);\n\n    return (\n        <MapWrapper id='map'></MapWrapper>\n    )\n}\n\nexport default LeafletMap;","import React from 'react';\nimport { Store } from '../../store/app.store';\nimport togpx from 'togpx';\nimport styled from 'styled-components';\n\nconst DownloadButton = styled.button`\n    border: 0;\n    background-color: #c3e452;\n    padding: 0.8rem;\n    border-radius: 5px;\n    color: #383838;\n    font-size: 1rem;\n    font-weight: bold;\n    opacity: 1;\n    transition: opacity 0.3s;\n    a {\n        text-decoration: none;\n        color: inherit;\n    }\n    :disabled {\n        opacity: 0;\n    }\n`;\n\nconst DownloadRoute = () => {\n    const { state, dispatch } = React.useContext(Store);\n    const createExportObj = {\n        \"type\": \"FeatureCollection\",\n        \"features\": [...state.markers, ...state.polylines]\n    }\n    const downloadDataUri = state.markers.length ? `data:text/json;charset=utf-8,${togpx(createExportObj)}` : null;\n    return (\n        <>\n        { downloadDataUri ?\n            <DownloadButton><a href={downloadDataUri} download=\"route.gpx\">Download Route</a></DownloadButton>\n        :\n            <DownloadButton disabled>Download Route</DownloadButton>\n        }\n        </>\n    )\n}\n\nexport default DownloadRoute;","import React from 'react';\nimport Styled from 'styled-components';\nimport { library } from '@fortawesome/fontawesome-svg-core'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faTrashAlt, faBars } from '@fortawesome/free-solid-svg-icons'\nimport WaypointList from './components/waypoint-list/waypoint-list.component';\nimport LeafletMap from './components/leaflet-map/leaflet-map.component';\nimport DownloadRoute from './components/download-route/download-route.component';\nimport { StoreProvider } from './store/app.store';\n\nlibrary.add(faTrashAlt, faBars);\n\nconst AppWrapper = Styled.div`\n  display: flex;\n  `;\nconst AppSidebar = Styled.div`\n  width: 20rem;\n  background-color: #383838;\n  height: 100vh;\n  padding: 1rem;\n  box-sizing: border-box;\n  color: #ffffff;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  `;\nconst AppTitle = Styled.h1`\n  margin: 0 0 3rem 0;\n  padding: 0 0 1rem 0;\n  font-size: 1.2rem;\n  border-bottom: 1px solid #fff;\n  `;\n\nfunction App() {\n  return (\n    <StoreProvider>\n      <AppWrapper>\n      <FontAwesomeIcon icon=\"fa-trash-alt\" />\n        <AppSidebar>\n          <div>\n            <AppTitle>Route Builder</AppTitle>\n            <WaypointList/>\n          </div>\n          <DownloadRoute/>\n        </AppSidebar>\n        <LeafletMap/>\n      </AppWrapper>\n    </StoreProvider>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}